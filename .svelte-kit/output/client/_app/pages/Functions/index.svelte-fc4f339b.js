import{S as De,i as Fe,s as We,e as l,t as n,k as c,c as r,a as u,h as s,d as t,m as h,b as He,g as a,G as i,K as de}from"../../chunks/vendor-4e552e70.js";function je(Me){let m,R,M,d,N,p,Q,U,D,y,V,F,v,X,W,b,Z,j,g,$,A,w,ee,C,k,te,G,I,oe,z,S,ae,L,T,ie,O,f,ne,_,se,le,re,ue,x,ce,Y,P,he,q,E,fe,B,J,me;return{c(){m=l("h2"),R=n("Introduction"),M=c(),d=l("p"),N=n("This website is built on the SvelteKit framework. It's located on a Linode Debian 11 server. The "),p=l("a"),Q=n("async_with_Websockets"),U=n(" page is supported by two WebSockets servers: a WebSocket server on a Digital Ocean Debian 11 droplet and the Linode server mentioned above."),D=c(),y=l("p"),V=n("Svelte modules look a lot like ordinary HTML pages, with JavaScript inside of script tags,  CSS in style tags, and, aside from just a few quirks, plain JavaScript. There's no virtual DOM. Svelte modules can be imported to facilitate reactivity and animation, among other things. Svelte is well documentat, with examples and interactive tutorials, so getting started and learning to use the modules effectively is not a daunting challenge. Power users will find many features useful for fine tuning special features."),F=c(),v=l("p"),X=n("The modules in this presentation are small and isolated from other modules, making them easy to understand and maintain. There are no compelling reasons to avoid mutations and side effects, or to impose explicit type constraints on functions. There's no danger of introducing bugs, as would be the case in larger modules with more than one function reading or modifying global variables."),W=c(),b=l("p"),Z=n("Functions that manipulate values other than those provided as arguments are dangerous where there are many lines of code. You might be scrupulously careful, but future maintainers might not understand your code as well as you do. If bugs appear, they might be difficult to trace."),j=c(),g=l("p"),$=n('When the global space is just a small, isolated module, many established "best practices" can be safely ignored. Deviations from usually adhered-to best practices are tolerated inside of functions; why not in small, isolated modules?'),A=c(),w=l("h3"),ee=n("Ersatz Monads"),C=c(),k=l("p"),te=n(`"Monad" is rigorously defined in Category Theory, but not in this presentation. Here, a monad is a recursive closure that returns a function that facilitates the composition of values (usualy functions) in ways that can be specified by the monad's definition. For example, the Promises Monad processes chains of values, mostly asynchronous functions, assigning results to various attributes of a global object that is synchronized with the DOM. The "monads" demonstration shows how a very simple monad can maintain and modify state isolated from the global space. The functions it consume power the solitaire version of the game of Score.`),G=c(),I=l("h3"),oe=n("Some Thoughts about Functional Programming"),z=c(),S=l("p"),ae=n('"Functional programming is an approach to programming based on function calls as the primary programming construct." - Greg Michaelson on Page 3 of An Introduction to Functional Programming Through Lambda Calculus.'),L=c(),T=l("p"),ie=n(`I created this section of the schalk.net site to share my enthusiasm for JavaScript functions, and especially for the recursive closures I call "monads". This are what come to mind when I think of "functional programming." The prevalent concept of "functional programming" involves using only pure functions and immutable values. I enjoy coding in Haskell that way, but mindlessly wasting the power and flexibility of JavaScript in situations where nothing can be gained from it doesn't seem very bright. These situations include code affecting on the internal workings of functions, and small modules where clobbering values used by other functions is easily avoided and side effects have nowhere to hide when debugging and refactoring occur. When benchmarkers evaluate the efficiency of having lots of modules, they overlook this important factor. Years ago, I elaborated on some of this in`),O=c(),f=l("p"),ne=n("I still have code for a fairly elaborate Haskell backend to an application I developed in 2013 and maintained for a while. It's a multi-player, multi-group simulated dice game based on a game my young son learned in school. It includes a shared group todo list and chat box. A version is online at "),_=l("a"),se=n("https://schalk.net/"),le=n(` The drag & drop boxes are too big, the buttons could be better arranged, and the rules are missing. Maybe I'll spruce it up someday. 
    `),re=l("br"),ue=c(),x=l("p"),ce=n(`The rules of the Game of Score are missing right now. They were there at one time but I haven't recovered those versions. If you want to check out the multi-player simulated dice game, click Group A or Group B or make up a group name. Click "refresh" whenever it is available, then click "Roll". You get a point for making the number 20 if you click "score" first and do it in at least two computations. If it is impossible to make 20 in two steps, you get a point for clicking "Impossible" but beware, not many rolls are impossible and you lose a point if there is a solution. If you are stymied, you can click "Solutions" and see what my Haskell algorithm, in which I have great confidence, reveals.`),Y=c(),P=l("p"),he=n("It's convenient sometimes, in the safety of small, isolated modules, to have functions rely on and mutate variables outside their scope. When your functions don't have to be pure; for example, when you are free to define functions that return results only on every third, fourth, or whatever execution, JavaScript becomes more flexible and powerful. These sorts of things are safe in small, isolated modules, just as they are inside of functions that rely only on their arguments and have no side effects."),q=c(),E=l("p"),fe=n("Trying to make JavaScript functions behave like Haskell functions can be enriching and for some, much more entertaining than sudoku or crossword puzzles. Such diversions, however, aren't likely to help us develop robust, easily maintainable applications."),B=c(),J=l("p"),me=n('In the modules that follow, I define functions, experiment with functions, admire the power and possibilities of functions, and generally dwell on functions. If, to you, "functional JavaScript" means "cargo-cult JavaScript" (superstitiously imitating Haskell and similar functional languages), then call me a heretic. Still, I hope you will at least consider the possibility that in some circumstances, abandoning strict adherence to the so-called "functional paradigm" can streamline your JavaScript code without risk.'),this.h()},l(e){m=r(e,"H2",{});var o=u(m);R=s(o,"Introduction"),o.forEach(t),M=h(e),d=r(e,"P",{});var K=u(d);N=s(K,"This website is built on the SvelteKit framework. It's located on a Linode Debian 11 server. The "),p=r(K,"A",{href:!0});var pe=u(p);Q=s(pe,"async_with_Websockets"),pe.forEach(t),U=s(K," page is supported by two WebSockets servers: a WebSocket server on a Digital Ocean Debian 11 droplet and the Linode server mentioned above."),K.forEach(t),D=h(e),y=r(e,"P",{});var ye=u(y);V=s(ye,"Svelte modules look a lot like ordinary HTML pages, with JavaScript inside of script tags,  CSS in style tags, and, aside from just a few quirks, plain JavaScript. There's no virtual DOM. Svelte modules can be imported to facilitate reactivity and animation, among other things. Svelte is well documentat, with examples and interactive tutorials, so getting started and learning to use the modules effectively is not a daunting challenge. Power users will find many features useful for fine tuning special features."),ye.forEach(t),F=h(e),v=r(e,"P",{});var ve=u(v);X=s(ve,"The modules in this presentation are small and isolated from other modules, making them easy to understand and maintain. There are no compelling reasons to avoid mutations and side effects, or to impose explicit type constraints on functions. There's no danger of introducing bugs, as would be the case in larger modules with more than one function reading or modifying global variables."),ve.forEach(t),W=h(e),b=r(e,"P",{});var be=u(b);Z=s(be,"Functions that manipulate values other than those provided as arguments are dangerous where there are many lines of code. You might be scrupulously careful, but future maintainers might not understand your code as well as you do. If bugs appear, they might be difficult to trace."),be.forEach(t),j=h(e),g=r(e,"P",{});var ge=u(g);$=s(ge,'When the global space is just a small, isolated module, many established "best practices" can be safely ignored. Deviations from usually adhered-to best practices are tolerated inside of functions; why not in small, isolated modules?'),ge.forEach(t),A=h(e),w=r(e,"H3",{});var we=u(w);ee=s(we,"Ersatz Monads"),we.forEach(t),C=h(e),k=r(e,"P",{});var ke=u(k);te=s(ke,`"Monad" is rigorously defined in Category Theory, but not in this presentation. Here, a monad is a recursive closure that returns a function that facilitates the composition of values (usualy functions) in ways that can be specified by the monad's definition. For example, the Promises Monad processes chains of values, mostly asynchronous functions, assigning results to various attributes of a global object that is synchronized with the DOM. The "monads" demonstration shows how a very simple monad can maintain and modify state isolated from the global space. The functions it consume power the solitaire version of the game of Score.`),ke.forEach(t),G=h(e),I=r(e,"H3",{});var Ie=u(I);oe=s(Ie,"Some Thoughts about Functional Programming"),Ie.forEach(t),z=h(e),S=r(e,"P",{});var Se=u(S);ae=s(Se,'"Functional programming is an approach to programming based on function calls as the primary programming construct." - Greg Michaelson on Page 3 of An Introduction to Functional Programming Through Lambda Calculus.'),Se.forEach(t),L=h(e),T=r(e,"P",{});var Te=u(T);ie=s(Te,`I created this section of the schalk.net site to share my enthusiasm for JavaScript functions, and especially for the recursive closures I call "monads". This are what come to mind when I think of "functional programming." The prevalent concept of "functional programming" involves using only pure functions and immutable values. I enjoy coding in Haskell that way, but mindlessly wasting the power and flexibility of JavaScript in situations where nothing can be gained from it doesn't seem very bright. These situations include code affecting on the internal workings of functions, and small modules where clobbering values used by other functions is easily avoided and side effects have nowhere to hide when debugging and refactoring occur. When benchmarkers evaluate the efficiency of having lots of modules, they overlook this important factor. Years ago, I elaborated on some of this in`),Te.forEach(t),O=h(e),f=r(e,"P",{});var H=u(f);ne=s(H,"I still have code for a fairly elaborate Haskell backend to an application I developed in 2013 and maintained for a while. It's a multi-player, multi-group simulated dice game based on a game my young son learned in school. It includes a shared group todo list and chat box. A version is online at "),_=r(H,"A",{href:!0});var _e=u(_);se=s(_e,"https://schalk.net/"),_e.forEach(t),le=s(H,` The drag & drop boxes are too big, the buttons could be better arranged, and the rules are missing. Maybe I'll spruce it up someday. 
    `),re=r(H,"BR",{}),ue=h(H),H.forEach(t),x=r(e,"P",{});var xe=u(x);ce=s(xe,`The rules of the Game of Score are missing right now. They were there at one time but I haven't recovered those versions. If you want to check out the multi-player simulated dice game, click Group A or Group B or make up a group name. Click "refresh" whenever it is available, then click "Roll". You get a point for making the number 20 if you click "score" first and do it in at least two computations. If it is impossible to make 20 in two steps, you get a point for clicking "Impossible" but beware, not many rolls are impossible and you lose a point if there is a solution. If you are stymied, you can click "Solutions" and see what my Haskell algorithm, in which I have great confidence, reveals.`),xe.forEach(t),Y=h(e),P=r(e,"P",{});var Pe=u(P);he=s(Pe,"It's convenient sometimes, in the safety of small, isolated modules, to have functions rely on and mutate variables outside their scope. When your functions don't have to be pure; for example, when you are free to define functions that return results only on every third, fourth, or whatever execution, JavaScript becomes more flexible and powerful. These sorts of things are safe in small, isolated modules, just as they are inside of functions that rely only on their arguments and have no side effects."),Pe.forEach(t),q=h(e),E=r(e,"P",{});var Ee=u(E);fe=s(Ee,"Trying to make JavaScript functions behave like Haskell functions can be enriching and for some, much more entertaining than sudoku or crossword puzzles. Such diversions, however, aren't likely to help us develop robust, easily maintainable applications."),Ee.forEach(t),B=h(e),J=r(e,"P",{});var Je=u(J);me=s(Je,'In the modules that follow, I define functions, experiment with functions, admire the power and possibilities of functions, and generally dwell on functions. If, to you, "functional JavaScript" means "cargo-cult JavaScript" (superstitiously imitating Haskell and similar functional languages), then call me a heretic. Still, I hope you will at least consider the possibility that in some circumstances, abandoning strict adherence to the so-called "functional paradigm" can streamline your JavaScript code without risk.'),Je.forEach(t),this.h()},h(){He(p,"href","Functions/Async_monad"),He(_,"href","schalk.net")},m(e,o){a(e,m,o),i(m,R),a(e,M,o),a(e,d,o),i(d,N),i(d,p),i(p,Q),i(d,U),a(e,D,o),a(e,y,o),i(y,V),a(e,F,o),a(e,v,o),i(v,X),a(e,W,o),a(e,b,o),i(b,Z),a(e,j,o),a(e,g,o),i(g,$),a(e,A,o),a(e,w,o),i(w,ee),a(e,C,o),a(e,k,o),i(k,te),a(e,G,o),a(e,I,o),i(I,oe),a(e,z,o),a(e,S,o),i(S,ae),a(e,L,o),a(e,T,o),i(T,ie),a(e,O,o),a(e,f,o),i(f,ne),i(f,_),i(_,se),i(f,le),i(f,re),i(f,ue),a(e,x,o),i(x,ce),a(e,Y,o),a(e,P,o),i(P,he),a(e,q,o),a(e,E,o),i(E,fe),a(e,B,o),a(e,J,o),i(J,me)},p:de,i:de,o:de,d(e){e&&t(m),e&&t(M),e&&t(d),e&&t(D),e&&t(y),e&&t(F),e&&t(v),e&&t(W),e&&t(b),e&&t(j),e&&t(g),e&&t(A),e&&t(w),e&&t(C),e&&t(k),e&&t(G),e&&t(I),e&&t(z),e&&t(S),e&&t(L),e&&t(T),e&&t(O),e&&t(f),e&&t(x),e&&t(Y),e&&t(P),e&&t(q),e&&t(E),e&&t(B),e&&t(J)}}}class Ce extends De{constructor(m){super();Fe(this,m,null,je,We,{})}}export{Ce as default};
