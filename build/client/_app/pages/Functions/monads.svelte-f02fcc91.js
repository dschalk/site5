import{S as Vi,i as Gi,s as Ki,e as r,k as f,t as m,Q as Qi,c as s,d as t,m as u,a as h,h as b,b as Z,f as v,G as p,g as l,L as _,j as P,M as gi,N as Xi,T as $i,O as Ji}from"../../chunks/vendor-a263fa63.js";function en(n){let w,a,I,R,F,ie,q,M,ne,ae,N,D,U,W,B,X,A,J,V,Y,c,G,K,fe,Ne,ue,j,S,pe,z,Se,xe,O,nt,Ae,Q,at,Oe,g,ft,He,E,Xt,ut,me,Jt,pt,be,Vt,mt,he,Gt,bt,ce,Kt,ht,ye,Qt,ct,L,gt,yt,ve,$t,vt,de,eo,dt,we,to,wt,ke,oo,kt,H,lo,_e,ro,so,Ee,io,no,_t,Te,i,d,x,Ce,mo,Et,Tr,bo,Tt,Mr,ho,Fe,Rr,Mt,ao=parseFloat(n[23](y)).toFixed(5).toString()+"",co,yo,vo,wo,De,Br,ko,Ue,Ir,_o,Eo,To,Mo,We,Pr,Ro,Ye,Bo,Io,Po,No,Le,Nr,So,Ze,xo,Ao,Oo,Ho,je,Sr,Co,ze,Fo,Do,Uo,Wo,qe,xr,Yo,Xe,Lo,Zo,jo,zo,Rt,Ar,qo,Bt,Or,Xo,It,Hr,Jo,C,Cr,fo=n[20](y).join(", ")+"",Vo,Fr,Go,Ko,Qo,go,Je,Dr,$o,Ve,Ur,el,Ge,Wr,tl,Ke,Yr,ol,ll,rl,sl,Me,Lr,Pt,Zr,jr,il,Nt,zr,nl,Qe,qr,uo=n[0](y)[4]+"",al,fl,$,ul,pl,ee,ml,bl,te,hl,cl,oe,yl,vl,le,Xr,po=n[0](y)[2]+"",dl,wl,kl,_l,El,ge,Jr,Tl,$e,Vr,Ml,et,Gr,Rl,tt,Kr,Bl,ot,Qr,Il,re,Pl,Nl,se,Sl,xl,Al,Ol,Hl,lt,gr,Cl,Fl,Dl,Ul,rt,$r,Wl,Re,Yl,Ll,Be,Zl,jl,Ie,zl,ql,Pe,Xl,Jl,Vl,Gl,Kl,st,es,Ql,it,ts,gl,St,os,$l,xt,ls,er,At,rs,tr,Ot,ss,or,Ht,is,lr,Ct,ns,rr,Ft,as,sr,Dt,fs,ir,Ut,us,nr,Wt,ps,ar,Yt,ms,fr,Lt,bs,ur,pr,mr,br,hr,cr,yr,vr,Zt,hs,dr,jt,cs,wr,zt,ys,k,vs,Ts;return{c(){w=r("link"),a=f(),I=r("br"),R=f(),F=r("div"),ie=m("**************************************************************************"),q=f(),M=r("div"),ne=r("br"),ae=m(`

A Very Simple Recursive Closure Insulates and Controls State Transformations`),D=f(),U=r("br"),W=f(),B=r("p"),X=m("JavaScript monads are defined in various ways online and in print. I wouldn't say any of these definitions are right or wrong. Everyone is entitled to an opinion. Some of my thoughts on the matter will be in "),A=r("a"),J=m("Home"),V=m(" and in an addendum."),Y=f(),c=r("p"),G=m("The function M() (below) returns the function go(), thereby forming a closure. The returned function is named to facilitate recursion. Here's the definition of M():"),K=f(),fe=r("pre"),Ne=m(n[41]),ue=f(),j=r("p"),S=m('M(x) is most useful when the closure is named or, more precisely, when the function returned by M(x) is named. When M(x) is asigned a variable name, the state of "x" in M(x) can be preserved, transformed, and later used when needed, as illustrated below:'),pe=f(),z=r("pre"),Se=m(n[47]),xe=f(),O=r("p"),nt=m("The value held in the closure can be obtained later"),Ae=f(),Q=r("pre"),at=m(n[48]),Oe=f(),g=r("p"),ft=m("And later"),He=f(),E=r("pre"),Xt=m(n[49]),ut=f(),me=r("p"),Jt=m('Here are a few more simple operations on the very simple monad "mon":'),pt=f(),be=r("p"),Vt=m("We can set the value of x to 4 with a fresh closure, mon = M(4), or we can modify the one we have:"),mt=f(),he=r("pre"),Gt=m(n[50]),bt=f(),ce=r("p"),Kt=m("These abreviations will be used from now on:"),ht=f(),ye=r("pre"),Qt=m(`var s = "stop";
var log = console.log;
`),ct=f(),L=r("span"),gt=m("Deep Clone:"),yt=f(),ve=r("span"),$t=m('I ran the following code in firefox.aurora. The result verifies that mon2 defined by "var mon2 = M(mon(s))" is a deep clone of mon. The mon2 closure is out of reach by everything in its outer scope, and the mon closure is no exception.'),vt=f(),de=r("pre"),eo=m(n[51]),dt=f(),we=r("p"),to=m("If you want to be certain that a computation won't clash with anything, you can use M() to perform computations without relying on variables."),wt=f(),ke=r("pre"),oo=m(n[52]),kt=f(),H=r("p"),lo=m('Recursive closures created by "M" will control a fairly complicated dice game called "Score" ('),_e=r("a"),ro=m("Link To Score"),so=m("). It's a solitaire version of a "),Ee=r("a"),io=m("multiplayer version of the game"),no=m(" I developed eight years ago based on a Haskell WebSockets server."),_t=f(),Te=r("p"),i=m('For solitaire version presented here, a function named "m2" will will form a closure with M as follows: "m2 = M(x)" where x = [ [], [], [], [], [0], [], [0], [] ]. m2 will consume functions that, as the definition of M specifies, operate on x inside of M. x will correspond to the current state of game play. After each click on a number or operator buttom, m2(fu) is called.  as seen on a computer monitor and will keep a record of all prior states for each roll of the dice. The record of prior states allows players to traverse the history of their choices . Players can revert to prior states of game play and then move back to more recent states. Traversing states back and forth makes the browser sluggish . They can also traverse prior states of the game in the oposite direction.'),d=f(),x=r("p"),Ce=m("In the solitaire version of the game of score below, x will be an array of arrays in the form x =  [ [], [], [], [], [], [], [], [], [] ] where x[0] starts out as four integers simulating a throw of two six-sided, one twelve-sided, and one twenty-sided dice. x[1] and x[3] contain the number selected by the player, x[2] is the selected operator, and x[4] keeps track of the number of successes until the player wins by reaching x[4] = 5, x[5] contains all prior states as the player selects numbers and operators and is used for reversing state a little or all the way back to the original roll, x[6] is an index of where in x[5] play is taking place, and x[7] contains every state during a round and uses x[6] to travers the history of game play forward. Before getting to that, here come two more simple examples. The first example shows callback functions used by buttons and text boxes. The second one shows operations on an array."),mo=f(),Et=r("p"),Tr=m("These are the demonstration's event handlers:"),bo=f(),Tt=r("pre"),Mr=m(n[46]),ho=f(),Fe=r("p"),Rr=m("m4(s) is "),Mt=r("span"),co=m(ao),yo=f(),vo=r("br"),wo=f(),De=r("button"),Br=m("m4(cube)"),ko=f(),Ue=r("button"),Ir=m("m4(square)"),_o=f(),Eo=r("br"),To=r("br"),Mo=f(),We=r("span"),Pr=m("To call m4(pow(n)), enter n in the box ->"),Ro=f(),Ye=r("input"),Bo=f(),Io=r("br"),Po=r("br"),No=f(),Le=r("span"),Nr=m("To call m4(add(n)), enter n in the box ->"),So=f(),Ze=r("input"),xo=f(),Ao=r("br"),Oo=r("br"),Ho=f(),je=r("span"),Sr=m("To call m4(mult(n)), enter n in the box ->"),Co=f(),ze=r("input"),Fo=f(),Do=r("br"),Uo=r("br"),Wo=f(),qe=r("span"),xr=m("To call m4(reset(n)), enter n in the box ->"),Yo=f(),Xe=r("input"),Lo=f(),Zo=r("br"),jo=r("br"),zo=f(),Rt=r("p"),Ar=m("Next, x will be an array. Here are the functions responsible for the interactive demonstration below:"),qo=f(),Bt=r("pre"),Or=m(n[42]),Xo=f(),It=r("p"),Hr=m(`If you click mon3 = mon3(g) four times and the click mon3 = mon3(g3), you will see that mon3(s) returns its original value, [1,2,3,4]. By the way, the "mon3 =" part of "mon3 = mon3(g)" is included solely to trigger updating of browser displays. Svelte doesn't have a virtual DOM, and merely changing objects isn't enough to trigger DOM updates. For example, arr = [1,2,3] doesn't change in the DOM when arr.push(888) is called. arr = arr afterwards or arr = arr.push(888) initially both do the trick.`),Jo=f(),C=r("div"),Cr=m("["),Vo=m(fo),Fr=m("]"),Go=f(),Ko=r("br"),Qo=r("br"),go=f(),Je=r("button"),Dr=m("mon3 = mon3(g)"),$o=f(),Ve=r("button"),Ur=m("mon3 = mon3(g2)"),el=f(),Ge=r("button"),Wr=m("mon3 = mon3(g3)"),tl=f(),Ke=r("button"),Yr=m("mon3 = mon3(x => [1,2,3,4])"),ol=f(),ll=r("br"),rl=r("br"),sl=f(),Me=r("p"),Lr=m("Now for the game of score, a game involving four dice and two or three-stage arithmetic computations with the goal of arriving at the number 20. My son Alex taught it to me a decade ago, when he was in middle school. I was also learning the Haskell programming language, so I developed a multiplayer online version with groups of interacting player, a chat box, and a shared-by-the-group todo list controlled by the Haskell WebSockets server backend. The backend could compute all possible solutions, if any existed, to any throw of the dice. It also identified all of the impossible-to-solve rolls. Users could change the default number of dice sides from 6,6,12,and 20 and the goal from the default value of 20. A version of it is online at "),Pt=r("a"),Zr=m("https://score.schalk.net"),jr=m("."),il=f(),Nt=r("p"),zr=m("This demonstration doesn't rely on a remote server, nor does it feature any Haskell code. It's just a little solitaire game providing an opportunity to consider the interesting possibilities of recursive closures. You can traverse the history of game play for current roll. If you make a mistake, you can take back your move and do something else. If you traverse back and forth over several number and operator selection, your computation will be very slow and the program might crash."),nl=f(),Qe=r("h3"),qr=m("Score: "),al=m(uo),fl=f(),$=r("button"),ul=m(n[2]),pl=f(),ee=r("button"),ml=m(n[3]),bl=f(),te=r("button"),hl=m(n[4]),cl=f(),oe=r("button"),yl=m(n[5]),vl=f(),le=r("span"),Xr=m("The operator is "),dl=m(po),wl=f(),kl=r("br"),_l=r("br"),El=f(),ge=r("button"),Jr=m("add"),Tl=f(),$e=r("button"),Vr=m("subtract"),Ml=f(),et=r("button"),Gr=m("multiply"),Rl=f(),tt=r("button"),Kr=m("divide"),Bl=f(),ot=r("button"),Qr=m("concat"),Il=f(),re=r("span"),Pl=m(n[1]),Nl=f(),se=r("span"),Sl=m(n[19]),xl=f(),Al=r("br"),Ol=r("br"),Hl=f(),lt=r("button"),gr=m("ROLL"),Cl=f(),Fl=r("br"),Dl=r("br"),Ul=f(),rt=r("button"),$r=m("test"),Wl=f(),Re=r("button"),Yl=m(n[14]),Ll=f(),Be=r("button"),Zl=m(n[15]),jl=f(),Ie=r("button"),zl=m(n[16]),ql=f(),Pe=r("button"),Xl=m(n[17]),Jl=f(),Vl=r("br"),Gl=r("br"),Kl=f(),st=r("button"),es=m("Back"),Ql=f(),it=r("button"),ts=m("Forward"),gl=f(),St=r("p"),os=m(`The function fu() is the brains behing the game of Score. Each time a number or operator is clicked, m2(fu) is called, the monad m2 is modified, and the change is reflected in the DOM. The state of play in M is an array of seven arrays. Let's call it ar. If an operator op is in ar[2] and two numbers a and b are in ar[1], fu calls calc(a,b,op) and the result is added to ar[0] and ar[3]. ar[0] are the numbers in the game interface. ar[3] hold numbers that have been computed. At least one of the numbers in ar[3] has to be used to compute 20 in order to gain a point. If the number of points reaches 5, fu causes "You win" to be displayed, sets the score back to 0, and calls runRoll, starting another round of play.`),$l=f(),xt=r("p"),ls=m(`At the end of fu(), two formatting functions are Called. The first, update(), refreshes the game buttons, causing them to reflect the current state of ar. The second hides buttons that correspond to values of undefine and shows buttons that correspond to numbers in ar. This is done by switching variables p in "style = 'display: p' back and forth between "none" and "inline".`),er=f(),At=r("pre"),rs=m(n[40]),tr=f(),Ot=r("p"),ss=m('Clicking "ROLL" calls runRoll() which, in turn, calls updateRoll() to re-set HTML variables.'),or=f(),Ht=r("pre"),is=m(n[43]),lr=f(),Ct=r("p"),ns=m(`The "x = [ [], [], [], [], [0], [], [0], [] ]" format will be maintained throught game play. x[0] simulates the dice roll; x[1] recieves integers that are clicked; x[2] holds the operator; and x[4] contains numbers that are computed. x[4] makes sure at least one computed number is involved in arriving at 20. That's the reason, toward the end of fu(), that the intersection of a[0] and a[4] is examined when 20 is computed. Here are the first few functions called when a number is clicked:`),rr=f(),Ft=r("pre"),as=m(n[44]),sr=f(),Dt=r("p"),fs=m(`The first line of fu() is the calculation result that is generated whenever there are two items in (s)[1] and an operator in m2(s)[3]. The intersection is important in fu()'s bottom test. If "intersect", the intersection of m2(s)[1] and m2(s)[3], is empty intersect[0] returns false and the last test in fu fails, even though 20 was produced on the second computation.`),ir=f(),Ut=r("p"),us=m("If no operator has been selected, it's possible to click a third number. The program doesn't complain, it just puts the number back for you with:"),nr=f(),Wt=r("pre"),ps=m(n[45]),ar=f(),Yt=r("p"),ms=m("If you roll the dice and keep clicking on the leftmost number, you'll see the numbers shift back and forth on every try. The first element of m2(s)[0] keeps getting pulled out of the first position and pushed back on the right."),fr=f(),Lt=r("p"),bs=m(`sfunc() does some more DOM housekeeping. The buttons with dice number come and go as their CSS display strings are changed back and forth between "none" and "inline". fu() calls sfunc(). Here's how it is defined:`),ur=f(),pr=r("br"),mr=r("br"),br=r("br"),hr=f(),cr=r("br"),yr=r("br"),vr=f(),Zt=r("h2"),hs=m("ADDENDUM"),dr=f(),jt=r("p"),cs=m(`I call functions returned by M "monads", much to the consternation of some "functional programmers" who scoff at the idea that JavaScript could possibly have monads such as those defined in the Haskell programming language. Neither my monads nor the Haskell monads are Category Theory monads. Haskell monads insulate chained computation from the global space, consuming functions that return new Monads. Mine happen to do the same thing. Haskell monads need to navegate through various types but I don't bother with that. The definition of "M" shows that the returned function responds to arguments that are functions and also to the string "Stop."`),wr=f(),zt=r("p"),ys=m(`In my opinion, trying to define JavaScript objects that resemble the basic monads found in the Haskell Prelude module, amusing though it may be, isn't likely to produce anything very useful. People who think Haskell, or the supposed mathematical category of Haskell types and functions called "Hask", are actually Category Theory categories are mistaken. Category Theory inspired the development of Haskell monads and it might not be merely coincidental that the monads I am about to define are functionally similar to Haskell monads, though superficially quite different. Both transform state along pipelines isolated from their outer scope by operating on functions that return new monads. Both preserve state for future transformations or for eventual use in their outer scopes. Mine call functions in their outer scopes in order to update the DOM, not having to wait to do it in a main() function. I'm not trying to mimic Haskell or any other functional programming language.`),this.h()},l(e){const o=Qi('[data-svelte="svelte-3yzzxp"]',document.head);w=s(o,"LINK",{rel:!0,href:!0}),o.forEach(t),a=u(e),I=s(e,"BR",{}),R=u(e),F=s(e,"DIV",{});var Ms=h(F);ie=b(Ms,"**************************************************************************"),Ms.forEach(t),q=u(e),M=s(e,"DIV",{style:!0});var ds=h(M);ne=s(ds,"BR",{}),ae=b(ds,`

A Very Simple Recursive Closure Insulates and Controls State Transformations`),ds.forEach(t),D=u(e),U=s(e,"BR",{}),W=u(e),B=s(e,"P",{});var kr=h(B);X=b(kr,"JavaScript monads are defined in various ways online and in print. I wouldn't say any of these definitions are right or wrong. Everyone is entitled to an opinion. Some of my thoughts on the matter will be in "),A=s(kr,"A",{href:!0});var Rs=h(A);J=b(Rs,"Home"),Rs.forEach(t),V=b(kr," and in an addendum."),kr.forEach(t),Y=u(e),c=s(e,"P",{});var Bs=h(c);G=b(Bs,"The function M() (below) returns the function go(), thereby forming a closure. The returned function is named to facilitate recursion. Here's the definition of M():"),Bs.forEach(t),K=u(e),fe=s(e,"PRE",{});var Is=h(fe);Ne=b(Is,n[41]),Is.forEach(t),ue=u(e),j=s(e,"P",{});var Ps=h(j);S=b(Ps,'M(x) is most useful when the closure is named or, more precisely, when the function returned by M(x) is named. When M(x) is asigned a variable name, the state of "x" in M(x) can be preserved, transformed, and later used when needed, as illustrated below:'),Ps.forEach(t),pe=u(e),z=s(e,"PRE",{});var Ns=h(z);Se=b(Ns,n[47]),Ns.forEach(t),xe=u(e),O=s(e,"P",{});var Ss=h(O);nt=b(Ss,"The value held in the closure can be obtained later"),Ss.forEach(t),Ae=u(e),Q=s(e,"PRE",{});var xs=h(Q);at=b(xs,n[48]),xs.forEach(t),Oe=u(e),g=s(e,"P",{});var As=h(g);ft=b(As,"And later"),As.forEach(t),He=u(e),E=s(e,"PRE",{});var Os=h(E);Xt=b(Os,n[49]),Os.forEach(t),ut=u(e),me=s(e,"P",{});var Hs=h(me);Jt=b(Hs,'Here are a few more simple operations on the very simple monad "mon":'),Hs.forEach(t),pt=u(e),be=s(e,"P",{});var Cs=h(be);Vt=b(Cs,"We can set the value of x to 4 with a fresh closure, mon = M(4), or we can modify the one we have:"),Cs.forEach(t),mt=u(e),he=s(e,"PRE",{});var Fs=h(he);Gt=b(Fs,n[50]),Fs.forEach(t),bt=u(e),ce=s(e,"P",{});var Ds=h(ce);Kt=b(Ds,"These abreviations will be used from now on:"),Ds.forEach(t),ht=u(e),ye=s(e,"PRE",{});var Us=h(ye);Qt=b(Us,`var s = "stop";
var log = console.log;
`),Us.forEach(t),ct=u(e),L=s(e,"SPAN",{style:!0});var Ws=h(L);gt=b(Ws,"Deep Clone:"),Ws.forEach(t),yt=u(e),ve=s(e,"SPAN",{});var Ys=h(ve);$t=b(Ys,'I ran the following code in firefox.aurora. The result verifies that mon2 defined by "var mon2 = M(mon(s))" is a deep clone of mon. The mon2 closure is out of reach by everything in its outer scope, and the mon closure is no exception.'),Ys.forEach(t),vt=u(e),de=s(e,"PRE",{});var Ls=h(de);eo=b(Ls,n[51]),Ls.forEach(t),dt=u(e),we=s(e,"P",{});var Zs=h(we);to=b(Zs,"If you want to be certain that a computation won't clash with anything, you can use M() to perform computations without relying on variables."),Zs.forEach(t),wt=u(e),ke=s(e,"PRE",{});var js=h(ke);oo=b(js,n[52]),js.forEach(t),kt=u(e),H=s(e,"P",{});var qt=h(H);lo=b(qt,'Recursive closures created by "M" will control a fairly complicated dice game called "Score" ('),_e=s(qt,"A",{href:!0});var zs=h(_e);ro=b(zs,"Link To Score"),zs.forEach(t),so=b(qt,"). It's a solitaire version of a "),Ee=s(qt,"A",{href:!0});var qs=h(Ee);io=b(qs,"multiplayer version of the game"),qs.forEach(t),no=b(qt," I developed eight years ago based on a Haskell WebSockets server."),qt.forEach(t),_t=u(e),Te=s(e,"P",{});var Xs=h(Te);i=b(Xs,'For solitaire version presented here, a function named "m2" will will form a closure with M as follows: "m2 = M(x)" where x = [ [], [], [], [], [0], [], [0], [] ]. m2 will consume functions that, as the definition of M specifies, operate on x inside of M. x will correspond to the current state of game play. After each click on a number or operator buttom, m2(fu) is called.  as seen on a computer monitor and will keep a record of all prior states for each roll of the dice. The record of prior states allows players to traverse the history of their choices . Players can revert to prior states of game play and then move back to more recent states. Traversing states back and forth makes the browser sluggish . They can also traverse prior states of the game in the oposite direction.'),Xs.forEach(t),d=u(e),x=s(e,"P",{});var Js=h(x);Ce=b(Js,"In the solitaire version of the game of score below, x will be an array of arrays in the form x =  [ [], [], [], [], [], [], [], [], [] ] where x[0] starts out as four integers simulating a throw of two six-sided, one twelve-sided, and one twenty-sided dice. x[1] and x[3] contain the number selected by the player, x[2] is the selected operator, and x[4] keeps track of the number of successes until the player wins by reaching x[4] = 5, x[5] contains all prior states as the player selects numbers and operators and is used for reversing state a little or all the way back to the original roll, x[6] is an index of where in x[5] play is taking place, and x[7] contains every state during a round and uses x[6] to travers the history of game play forward. Before getting to that, here come two more simple examples. The first example shows callback functions used by buttons and text boxes. The second one shows operations on an array."),Js.forEach(t),mo=u(e),Et=s(e,"P",{});var Vs=h(Et);Tr=b(Vs,"These are the demonstration's event handlers:"),Vs.forEach(t),bo=u(e),Tt=s(e,"PRE",{});var Gs=h(Tt);Mr=b(Gs,n[46]),Gs.forEach(t),ho=u(e),Fe=s(e,"P",{});var ws=h(Fe);Rr=b(ws,"m4(s) is "),Mt=s(ws,"SPAN",{style:!0});var Ks=h(Mt);co=b(Ks,ao),Ks.forEach(t),ws.forEach(t),yo=u(e),vo=s(e,"BR",{}),wo=u(e),De=s(e,"BUTTON",{});var Qs=h(De);Br=b(Qs,"m4(cube)"),Qs.forEach(t),ko=u(e),Ue=s(e,"BUTTON",{});var gs=h(Ue);Ir=b(gs,"m4(square)"),gs.forEach(t),_o=u(e),Eo=s(e,"BR",{}),To=s(e,"BR",{}),Mo=u(e),We=s(e,"SPAN",{style:!0});var $s=h(We);Pr=b($s,"To call m4(pow(n)), enter n in the box ->"),$s.forEach(t),Ro=u(e),Ye=s(e,"INPUT",{type:!0,style:!0}),Bo=u(e),Io=s(e,"BR",{}),Po=s(e,"BR",{}),No=u(e),Le=s(e,"SPAN",{style:!0});var ei=h(Le);Nr=b(ei,"To call m4(add(n)), enter n in the box ->"),ei.forEach(t),So=u(e),Ze=s(e,"INPUT",{type:!0,style:!0}),xo=u(e),Ao=s(e,"BR",{}),Oo=s(e,"BR",{}),Ho=u(e),je=s(e,"SPAN",{style:!0});var ti=h(je);Sr=b(ti,"To call m4(mult(n)), enter n in the box ->"),ti.forEach(t),Co=u(e),ze=s(e,"INPUT",{type:!0,style:!0}),Fo=u(e),Do=s(e,"BR",{}),Uo=s(e,"BR",{}),Wo=u(e),qe=s(e,"SPAN",{style:!0});var oi=h(qe);xr=b(oi,"To call m4(reset(n)), enter n in the box ->"),oi.forEach(t),Yo=u(e),Xe=s(e,"INPUT",{type:!0,style:!0}),Lo=u(e),Zo=s(e,"BR",{}),jo=s(e,"BR",{}),zo=u(e),Rt=s(e,"P",{});var li=h(Rt);Ar=b(li,"Next, x will be an array. Here are the functions responsible for the interactive demonstration below:"),li.forEach(t),qo=u(e),Bt=s(e,"PRE",{});var ri=h(Bt);Or=b(ri,n[42]),ri.forEach(t),Xo=u(e),It=s(e,"P",{});var si=h(It);Hr=b(si,`If you click mon3 = mon3(g) four times and the click mon3 = mon3(g3), you will see that mon3(s) returns its original value, [1,2,3,4]. By the way, the "mon3 =" part of "mon3 = mon3(g)" is included solely to trigger updating of browser displays. Svelte doesn't have a virtual DOM, and merely changing objects isn't enough to trigger DOM updates. For example, arr = [1,2,3] doesn't change in the DOM when arr.push(888) is called. arr = arr afterwards or arr = arr.push(888) initially both do the trick.`),si.forEach(t),Jo=u(e),C=s(e,"DIV",{id:!0,style:!0});var _r=h(C);Cr=b(_r,"["),Vo=b(_r,fo),Fr=b(_r,"]"),_r.forEach(t),Go=u(e),Ko=s(e,"BR",{}),Qo=s(e,"BR",{}),go=u(e),Je=s(e,"BUTTON",{});var ii=h(Je);Dr=b(ii,"mon3 = mon3(g)"),ii.forEach(t),$o=u(e),Ve=s(e,"BUTTON",{});var ni=h(Ve);Ur=b(ni,"mon3 = mon3(g2)"),ni.forEach(t),el=u(e),Ge=s(e,"BUTTON",{});var ai=h(Ge);Wr=b(ai,"mon3 = mon3(g3)"),ai.forEach(t),tl=u(e),Ke=s(e,"BUTTON",{});var fi=h(Ke);Yr=b(fi,"mon3 = mon3(x => [1,2,3,4])"),fi.forEach(t),ol=u(e),ll=s(e,"BR",{}),rl=s(e,"BR",{}),sl=u(e),Me=s(e,"P",{});var Er=h(Me);Lr=b(Er,"Now for the game of score, a game involving four dice and two or three-stage arithmetic computations with the goal of arriving at the number 20. My son Alex taught it to me a decade ago, when he was in middle school. I was also learning the Haskell programming language, so I developed a multiplayer online version with groups of interacting player, a chat box, and a shared-by-the-group todo list controlled by the Haskell WebSockets server backend. The backend could compute all possible solutions, if any existed, to any throw of the dice. It also identified all of the impossible-to-solve rolls. Users could change the default number of dice sides from 6,6,12,and 20 and the goal from the default value of 20. A version of it is online at "),Pt=s(Er,"A",{href:!0});var ui=h(Pt);Zr=b(ui,"https://score.schalk.net"),ui.forEach(t),jr=b(Er,"."),Er.forEach(t),il=u(e),Nt=s(e,"P",{});var pi=h(Nt);zr=b(pi,"This demonstration doesn't rely on a remote server, nor does it feature any Haskell code. It's just a little solitaire game providing an opportunity to consider the interesting possibilities of recursive closures. You can traverse the history of game play for current roll. If you make a mistake, you can take back your move and do something else. If you traverse back and forth over several number and operator selection, your computation will be very slow and the program might crash."),pi.forEach(t),nl=u(e),Qe=s(e,"H3",{});var ks=h(Qe);qr=b(ks,"Score: "),al=b(ks,uo),ks.forEach(t),fl=u(e),$=s(e,"BUTTON",{style:!0});var mi=h($);ul=b(mi,n[2]),mi.forEach(t),pl=u(e),ee=s(e,"BUTTON",{style:!0});var bi=h(ee);ml=b(bi,n[3]),bi.forEach(t),bl=u(e),te=s(e,"BUTTON",{style:!0});var hi=h(te);hl=b(hi,n[4]),hi.forEach(t),cl=u(e),oe=s(e,"BUTTON",{style:!0});var ci=h(oe);yl=b(ci,n[5]),ci.forEach(t),vl=u(e),le=s(e,"SPAN",{style:!0});var _s=h(le);Xr=b(_s,"The operator is "),dl=b(_s,po),_s.forEach(t),wl=u(e),kl=s(e,"BR",{}),_l=s(e,"BR",{}),El=u(e),ge=s(e,"BUTTON",{});var yi=h(ge);Jr=b(yi,"add"),yi.forEach(t),Tl=u(e),$e=s(e,"BUTTON",{});var vi=h($e);Vr=b(vi,"subtract"),vi.forEach(t),Ml=u(e),et=s(e,"BUTTON",{});var di=h(et);Gr=b(di,"multiply"),di.forEach(t),Rl=u(e),tt=s(e,"BUTTON",{});var wi=h(tt);Kr=b(wi,"divide"),wi.forEach(t),Bl=u(e),ot=s(e,"BUTTON",{});var ki=h(ot);Qr=b(ki,"concat"),ki.forEach(t),Il=u(e),re=s(e,"SPAN",{style:!0});var _i=h(re);Pl=b(_i,n[1]),_i.forEach(t),Nl=u(e),se=s(e,"SPAN",{style:!0});var Ei=h(se);Sl=b(Ei,n[19]),Ei.forEach(t),xl=u(e),Al=s(e,"BR",{}),Ol=s(e,"BR",{}),Hl=u(e),lt=s(e,"BUTTON",{});var Ti=h(lt);gr=b(Ti,"ROLL"),Ti.forEach(t),Cl=u(e),Fl=s(e,"BR",{}),Dl=s(e,"BR",{}),Ul=u(e),rt=s(e,"BUTTON",{});var Mi=h(rt);$r=b(Mi,"test"),Mi.forEach(t),Wl=u(e),Re=s(e,"BUTTON",{style:!0});var Ri=h(Re);Yl=b(Ri,n[14]),Ri.forEach(t),Ll=u(e),Be=s(e,"BUTTON",{style:!0});var Bi=h(Be);Zl=b(Bi,n[15]),Bi.forEach(t),jl=u(e),Ie=s(e,"BUTTON",{style:!0});var Ii=h(Ie);zl=b(Ii,n[16]),Ii.forEach(t),ql=u(e),Pe=s(e,"BUTTON",{style:!0});var Pi=h(Pe);Xl=b(Pi,n[17]),Pi.forEach(t),Jl=u(e),Vl=s(e,"BR",{}),Gl=s(e,"BR",{}),Kl=u(e),st=s(e,"BUTTON",{});var Ni=h(st);es=b(Ni,"Back"),Ni.forEach(t),Ql=u(e),it=s(e,"BUTTON",{});var Si=h(it);ts=b(Si,"Forward"),Si.forEach(t),gl=u(e),St=s(e,"P",{});var xi=h(St);os=b(xi,`The function fu() is the brains behing the game of Score. Each time a number or operator is clicked, m2(fu) is called, the monad m2 is modified, and the change is reflected in the DOM. The state of play in M is an array of seven arrays. Let's call it ar. If an operator op is in ar[2] and two numbers a and b are in ar[1], fu calls calc(a,b,op) and the result is added to ar[0] and ar[3]. ar[0] are the numbers in the game interface. ar[3] hold numbers that have been computed. At least one of the numbers in ar[3] has to be used to compute 20 in order to gain a point. If the number of points reaches 5, fu causes "You win" to be displayed, sets the score back to 0, and calls runRoll, starting another round of play.`),xi.forEach(t),$l=u(e),xt=s(e,"P",{});var Ai=h(xt);ls=b(Ai,`At the end of fu(), two formatting functions are Called. The first, update(), refreshes the game buttons, causing them to reflect the current state of ar. The second hides buttons that correspond to values of undefine and shows buttons that correspond to numbers in ar. This is done by switching variables p in "style = 'display: p' back and forth between "none" and "inline".`),Ai.forEach(t),er=u(e),At=s(e,"PRE",{});var Oi=h(At);rs=b(Oi,n[40]),Oi.forEach(t),tr=u(e),Ot=s(e,"P",{});var Hi=h(Ot);ss=b(Hi,'Clicking "ROLL" calls runRoll() which, in turn, calls updateRoll() to re-set HTML variables.'),Hi.forEach(t),or=u(e),Ht=s(e,"PRE",{});var Ci=h(Ht);is=b(Ci,n[43]),Ci.forEach(t),lr=u(e),Ct=s(e,"P",{});var Fi=h(Ct);ns=b(Fi,`The "x = [ [], [], [], [], [0], [], [0], [] ]" format will be maintained throught game play. x[0] simulates the dice roll; x[1] recieves integers that are clicked; x[2] holds the operator; and x[4] contains numbers that are computed. x[4] makes sure at least one computed number is involved in arriving at 20. That's the reason, toward the end of fu(), that the intersection of a[0] and a[4] is examined when 20 is computed. Here are the first few functions called when a number is clicked:`),Fi.forEach(t),rr=u(e),Ft=s(e,"PRE",{});var Di=h(Ft);as=b(Di,n[44]),Di.forEach(t),sr=u(e),Dt=s(e,"P",{});var Ui=h(Dt);fs=b(Ui,`The first line of fu() is the calculation result that is generated whenever there are two items in (s)[1] and an operator in m2(s)[3]. The intersection is important in fu()'s bottom test. If "intersect", the intersection of m2(s)[1] and m2(s)[3], is empty intersect[0] returns false and the last test in fu fails, even though 20 was produced on the second computation.`),Ui.forEach(t),ir=u(e),Ut=s(e,"P",{});var Wi=h(Ut);us=b(Wi,"If no operator has been selected, it's possible to click a third number. The program doesn't complain, it just puts the number back for you with:"),Wi.forEach(t),nr=u(e),Wt=s(e,"PRE",{});var Yi=h(Wt);ps=b(Yi,n[45]),Yi.forEach(t),ar=u(e),Yt=s(e,"P",{});var Li=h(Yt);ms=b(Li,"If you roll the dice and keep clicking on the leftmost number, you'll see the numbers shift back and forth on every try. The first element of m2(s)[0] keeps getting pulled out of the first position and pushed back on the right."),Li.forEach(t),fr=u(e),Lt=s(e,"P",{});var Zi=h(Lt);bs=b(Zi,`sfunc() does some more DOM housekeeping. The buttons with dice number come and go as their CSS display strings are changed back and forth between "none" and "inline". fu() calls sfunc(). Here's how it is defined:`),Zi.forEach(t),ur=u(e),pr=s(e,"BR",{}),mr=s(e,"BR",{}),br=s(e,"BR",{}),hr=u(e),cr=s(e,"BR",{}),yr=s(e,"BR",{}),vr=u(e),Zt=s(e,"H2",{});var ji=h(Zt);hs=b(ji,"ADDENDUM"),ji.forEach(t),dr=u(e),jt=s(e,"P",{});var zi=h(jt);cs=b(zi,`I call functions returned by M "monads", much to the consternation of some "functional programmers" who scoff at the idea that JavaScript could possibly have monads such as those defined in the Haskell programming language. Neither my monads nor the Haskell monads are Category Theory monads. Haskell monads insulate chained computation from the global space, consuming functions that return new Monads. Mine happen to do the same thing. Haskell monads need to navegate through various types but I don't bother with that. The definition of "M" shows that the returned function responds to arguments that are functions and also to the string "Stop."`),zi.forEach(t),wr=u(e),zt=s(e,"P",{});var qi=h(zt);ys=b(qi,`In my opinion, trying to define JavaScript objects that resemble the basic monads found in the Haskell Prelude module, amusing though it may be, isn't likely to produce anything very useful. People who think Haskell, or the supposed mathematical category of Haskell types and functions called "Hask", are actually Category Theory categories are mistaken. Category Theory inspired the development of Haskell monads and it might not be merely coincidental that the monads I am about to define are functionally similar to Haskell monads, though superficially quite different. Both transform state along pipelines isolated from their outer scope by operating on functions that return new monads. Both preserve state for future transformations or for eventual use in their outer scopes. Mine call functions in their outer scopes in order to update the DOM, not having to wait to do it in a main() function. I'm not trying to mimic Haskell or any other functional programming language.`),qi.forEach(t),this.h()},h(){document.title="Recursive Closures Without Mutating State ",Z(w,"rel","stylesheet"),Z(w,"href","../Functions/style.css"),v(M,"font-family","Times New Roman"),v(M,"text-align","center"),v(M,"font-size","32px"),Z(A,"href","./"),v(L,"font-size","26px"),v(L,"color","gold"),v(L,"text-decoration","underline"),Z(_e,"href","#score"),Z(Ee,"href","https://score.schalk.net"),v(Mt,"font-size","54px"),v(We,"font-size","24px"),Z(Ye,"type","text"),v(Ye,"width","65px"),v(Le,"font-size","24px"),Z(Ze,"type","number"),v(Ze,"width","65px"),v(je,"font-size","24px"),Z(ze,"type","text"),v(ze,"width","65px"),v(qe,"font-size","24px"),Z(Xe,"type","number"),v(Xe,"width","65px"),Z(C,"id","score"),v(C,"margin-left","10%"),v(C,"font-size","44px"),v(C,"color","#ddaadd"),Z(Pt,"href","https://score.schalk.net"),v($,"display",n[6]),v(ee,"display",n[7]),v(te,"display",n[8]),v(oe,"display",n[9]),v(le,"margin-left","8%"),v(le,"font-size","22px"),v(re,"margin-left","20px"),v(re,"color","#bbbbff"),v(re,"font-size","28px"),v(se,"margin-left","20px"),v(se,"color","#bbbbff"),v(se,"font-size","38px"),v(Re,"display",n[10]),v(Be,"display",n[11]),v(Ie,"display",n[12]),v(Pe,"display",n[13])},m(e,o){p(document.head,w),l(e,a,o),l(e,I,o),l(e,R,o),l(e,F,o),p(F,ie),l(e,q,o),l(e,M,o),p(M,ne),p(M,ae),l(e,D,o),l(e,U,o),l(e,W,o),l(e,B,o),p(B,X),p(B,A),p(A,J),p(B,V),l(e,Y,o),l(e,c,o),p(c,G),l(e,K,o),l(e,fe,o),p(fe,Ne),l(e,ue,o),l(e,j,o),p(j,S),l(e,pe,o),l(e,z,o),p(z,Se),l(e,xe,o),l(e,O,o),p(O,nt),l(e,Ae,o),l(e,Q,o),p(Q,at),l(e,Oe,o),l(e,g,o),p(g,ft),l(e,He,o),l(e,E,o),p(E,Xt),l(e,ut,o),l(e,me,o),p(me,Jt),l(e,pt,o),l(e,be,o),p(be,Vt),l(e,mt,o),l(e,he,o),p(he,Gt),l(e,bt,o),l(e,ce,o),p(ce,Kt),l(e,ht,o),l(e,ye,o),p(ye,Qt),l(e,ct,o),l(e,L,o),p(L,gt),l(e,yt,o),l(e,ve,o),p(ve,$t),l(e,vt,o),l(e,de,o),p(de,eo),l(e,dt,o),l(e,we,o),p(we,to),l(e,wt,o),l(e,ke,o),p(ke,oo),l(e,kt,o),l(e,H,o),p(H,lo),p(H,_e),p(_e,ro),p(H,so),p(H,Ee),p(Ee,io),p(H,no),l(e,_t,o),l(e,Te,o),p(Te,i),l(e,d,o),l(e,x,o),p(x,Ce),l(e,mo,o),l(e,Et,o),p(Et,Tr),l(e,bo,o),l(e,Tt,o),p(Tt,Mr),l(e,ho,o),l(e,Fe,o),p(Fe,Rr),p(Fe,Mt),p(Mt,co),l(e,yo,o),l(e,vo,o),l(e,wo,o),l(e,De,o),p(De,Br),l(e,ko,o),l(e,Ue,o),p(Ue,Ir),l(e,_o,o),l(e,Eo,o),l(e,To,o),l(e,Mo,o),l(e,We,o),p(We,Pr),l(e,Ro,o),l(e,Ye,o),l(e,Bo,o),l(e,Io,o),l(e,Po,o),l(e,No,o),l(e,Le,o),p(Le,Nr),l(e,So,o),l(e,Ze,o),l(e,xo,o),l(e,Ao,o),l(e,Oo,o),l(e,Ho,o),l(e,je,o),p(je,Sr),l(e,Co,o),l(e,ze,o),l(e,Fo,o),l(e,Do,o),l(e,Uo,o),l(e,Wo,o),l(e,qe,o),p(qe,xr),l(e,Yo,o),l(e,Xe,o),l(e,Lo,o),l(e,Zo,o),l(e,jo,o),l(e,zo,o),l(e,Rt,o),p(Rt,Ar),l(e,qo,o),l(e,Bt,o),p(Bt,Or),l(e,Xo,o),l(e,It,o),p(It,Hr),l(e,Jo,o),l(e,C,o),p(C,Cr),p(C,Vo),p(C,Fr),l(e,Go,o),l(e,Ko,o),l(e,Qo,o),l(e,go,o),l(e,Je,o),p(Je,Dr),l(e,$o,o),l(e,Ve,o),p(Ve,Ur),l(e,el,o),l(e,Ge,o),p(Ge,Wr),l(e,tl,o),l(e,Ke,o),p(Ke,Yr),l(e,ol,o),l(e,ll,o),l(e,rl,o),l(e,sl,o),l(e,Me,o),p(Me,Lr),p(Me,Pt),p(Pt,Zr),p(Me,jr),l(e,il,o),l(e,Nt,o),p(Nt,zr),l(e,nl,o),l(e,Qe,o),p(Qe,qr),p(Qe,al),l(e,fl,o),l(e,$,o),p($,ul),l(e,pl,o),l(e,ee,o),p(ee,ml),l(e,bl,o),l(e,te,o),p(te,hl),l(e,cl,o),l(e,oe,o),p(oe,yl),l(e,vl,o),l(e,le,o),p(le,Xr),p(le,dl),l(e,wl,o),l(e,kl,o),l(e,_l,o),l(e,El,o),l(e,ge,o),p(ge,Jr),l(e,Tl,o),l(e,$e,o),p($e,Vr),l(e,Ml,o),l(e,et,o),p(et,Gr),l(e,Rl,o),l(e,tt,o),p(tt,Kr),l(e,Bl,o),l(e,ot,o),p(ot,Qr),l(e,Il,o),l(e,re,o),p(re,Pl),l(e,Nl,o),l(e,se,o),p(se,Sl),l(e,xl,o),l(e,Al,o),l(e,Ol,o),l(e,Hl,o),l(e,lt,o),p(lt,gr),l(e,Cl,o),l(e,Fl,o),l(e,Dl,o),l(e,Ul,o),l(e,rt,o),p(rt,$r),l(e,Wl,o),l(e,Re,o),p(Re,Yl),l(e,Ll,o),l(e,Be,o),p(Be,Zl),l(e,jl,o),l(e,Ie,o),p(Ie,zl),l(e,ql,o),l(e,Pe,o),p(Pe,Xl),l(e,Jl,o),l(e,Vl,o),l(e,Gl,o),l(e,Kl,o),l(e,st,o),p(st,es),l(e,Ql,o),l(e,it,o),p(it,ts),l(e,gl,o),l(e,St,o),p(St,os),l(e,$l,o),l(e,xt,o),p(xt,ls),l(e,er,o),l(e,At,o),p(At,rs),l(e,tr,o),l(e,Ot,o),p(Ot,ss),l(e,or,o),l(e,Ht,o),p(Ht,is),l(e,lr,o),l(e,Ct,o),p(Ct,ns),l(e,rr,o),l(e,Ft,o),p(Ft,as),l(e,sr,o),l(e,Dt,o),p(Dt,fs),l(e,ir,o),l(e,Ut,o),p(Ut,us),l(e,nr,o),l(e,Wt,o),p(Wt,ps),l(e,ar,o),l(e,Yt,o),p(Yt,ms),l(e,fr,o),l(e,Lt,o),p(Lt,bs),l(e,ur,o),l(e,pr,o),l(e,mr,o),l(e,br,o),l(e,hr,o),l(e,cr,o),l(e,yr,o),l(e,vr,o),l(e,Zt,o),p(Zt,hs),l(e,dr,o),l(e,jt,o),p(jt,cs),l(e,wr,o),l(e,zt,o),p(zt,ys),k=!0,vs||(Ts=[_(De,"click",n[35]),_(Ue,"click",n[34]),_(Ye,"keydown",n[36]),_(Ze,"keydown",n[37]),_(ze,"keydown",n[38]),_(Xe,"keydown",n[39]),_(Je,"click",n[53]),_(Ve,"click",n[54]),_(Ge,"click",n[55]),_(Ke,"click",n[56]),_($,"click",n[57]),_(ee,"click",n[58]),_(te,"click",n[59]),_(oe,"click",n[60]),_(ge,"click",n[61]),_($e,"click",n[62]),_(et,"click",n[63]),_(tt,"click",n[64]),_(ot,"click",n[65]),_(lt,"click",n[66]),_(rt,"click",n[67]),_(st,"click",n[68]),_(it,"click",n[69])],vs=!0)},p(e,o){(!k||o[0]&8388608)&&ao!==(ao=parseFloat(e[23](y)).toFixed(5).toString()+"")&&P(co,ao),(!k||o[0]&1048576)&&fo!==(fo=e[20](y).join(", ")+"")&&P(Vo,fo),(!k||o[0]&1)&&uo!==(uo=e[0](y)[4]+"")&&P(al,uo),(!k||o[0]&4)&&P(ul,e[2]),(!k||o[0]&64)&&v($,"display",e[6]),(!k||o[0]&8)&&P(ml,e[3]),(!k||o[0]&128)&&v(ee,"display",e[7]),(!k||o[0]&16)&&P(hl,e[4]),(!k||o[0]&256)&&v(te,"display",e[8]),(!k||o[0]&32)&&P(yl,e[5]),(!k||o[0]&512)&&v(oe,"display",e[9]),(!k||o[0]&1)&&po!==(po=e[0](y)[2]+"")&&P(dl,po),(!k||o[0]&2)&&P(Pl,e[1]),(!k||o[0]&524288)&&P(Sl,e[19]),(!k||o[0]&16384)&&P(Yl,e[14]),(!k||o[0]&1024)&&v(Re,"display",e[10]),(!k||o[0]&32768)&&P(Zl,e[15]),(!k||o[0]&2048)&&v(Be,"display",e[11]),(!k||o[0]&65536)&&P(zl,e[16]),(!k||o[0]&4096)&&v(Ie,"display",e[12]),(!k||o[0]&131072)&&P(Xl,e[17]),(!k||o[0]&8192)&&v(Pe,"display",e[13])},i(e){k||(gi(()=>{N||(N=Xi(M,Ji,{},!0)),N.run(1)}),k=!0)},o(e){N||(N=Xi(M,Ji,{},!1)),N.run(0),k=!1},d(e){t(w),e&&t(a),e&&t(I),e&&t(R),e&&t(F),e&&t(q),e&&t(M),e&&N&&N.end(),e&&t(D),e&&t(U),e&&t(W),e&&t(B),e&&t(Y),e&&t(c),e&&t(K),e&&t(fe),e&&t(ue),e&&t(j),e&&t(pe),e&&t(z),e&&t(xe),e&&t(O),e&&t(Ae),e&&t(Q),e&&t(Oe),e&&t(g),e&&t(He),e&&t(E),e&&t(ut),e&&t(me),e&&t(pt),e&&t(be),e&&t(mt),e&&t(he),e&&t(bt),e&&t(ce),e&&t(ht),e&&t(ye),e&&t(ct),e&&t(L),e&&t(yt),e&&t(ve),e&&t(vt),e&&t(de),e&&t(dt),e&&t(we),e&&t(wt),e&&t(ke),e&&t(kt),e&&t(H),e&&t(_t),e&&t(Te),e&&t(d),e&&t(x),e&&t(mo),e&&t(Et),e&&t(bo),e&&t(Tt),e&&t(ho),e&&t(Fe),e&&t(yo),e&&t(vo),e&&t(wo),e&&t(De),e&&t(ko),e&&t(Ue),e&&t(_o),e&&t(Eo),e&&t(To),e&&t(Mo),e&&t(We),e&&t(Ro),e&&t(Ye),e&&t(Bo),e&&t(Io),e&&t(Po),e&&t(No),e&&t(Le),e&&t(So),e&&t(Ze),e&&t(xo),e&&t(Ao),e&&t(Oo),e&&t(Ho),e&&t(je),e&&t(Co),e&&t(ze),e&&t(Fo),e&&t(Do),e&&t(Uo),e&&t(Wo),e&&t(qe),e&&t(Yo),e&&t(Xe),e&&t(Lo),e&&t(Zo),e&&t(jo),e&&t(zo),e&&t(Rt),e&&t(qo),e&&t(Bt),e&&t(Xo),e&&t(It),e&&t(Jo),e&&t(C),e&&t(Go),e&&t(Ko),e&&t(Qo),e&&t(go),e&&t(Je),e&&t($o),e&&t(Ve),e&&t(el),e&&t(Ge),e&&t(tl),e&&t(Ke),e&&t(ol),e&&t(ll),e&&t(rl),e&&t(sl),e&&t(Me),e&&t(il),e&&t(Nt),e&&t(nl),e&&t(Qe),e&&t(fl),e&&t($),e&&t(pl),e&&t(ee),e&&t(bl),e&&t(te),e&&t(cl),e&&t(oe),e&&t(vl),e&&t(le),e&&t(wl),e&&t(kl),e&&t(_l),e&&t(El),e&&t(ge),e&&t(Tl),e&&t($e),e&&t(Ml),e&&t(et),e&&t(Rl),e&&t(tt),e&&t(Bl),e&&t(ot),e&&t(Il),e&&t(re),e&&t(Nl),e&&t(se),e&&t(xl),e&&t(Al),e&&t(Ol),e&&t(Hl),e&&t(lt),e&&t(Cl),e&&t(Fl),e&&t(Dl),e&&t(Ul),e&&t(rt),e&&t(Wl),e&&t(Re),e&&t(Ll),e&&t(Be),e&&t(jl),e&&t(Ie),e&&t(ql),e&&t(Pe),e&&t(Jl),e&&t(Vl),e&&t(Gl),e&&t(Kl),e&&t(st),e&&t(Ql),e&&t(it),e&&t(gl),e&&t(St),e&&t($l),e&&t(xt),e&&t(er),e&&t(At),e&&t(tr),e&&t(Ot),e&&t(or),e&&t(Ht),e&&t(lr),e&&t(Ct),e&&t(rr),e&&t(Ft),e&&t(sr),e&&t(Dt),e&&t(ir),e&&t(Ut),e&&t(nr),e&&t(Wt),e&&t(ar),e&&t(Yt),e&&t(fr),e&&t(Lt),e&&t(ur),e&&t(pr),e&&t(mr),e&&t(br),e&&t(hr),e&&t(cr),e&&t(yr),e&&t(vr),e&&t(Zt),e&&t(dr),e&&t(jt),e&&t(wr),e&&t(zt),vs=!1,$i(Ts)}}}var y="stop";function tn(n,w,a){var I=parseInt(n,10),R=parseInt(w,10);return a==="+"?I+R:a==="*"?I*R:a==="-"?I-R:a==="/"?I/R:a==="@"?" "+I+R:"fubar"}function on(n){var w=n.pop()**3;return n.unshift(w),n}function ln(n){return n.flatMap(w=>(w+1)**3)}function rn(n){return n.flatMap(w=>Math.round(w**(1/3)))}function T(n){return function w(a){if(typeof a=="function")return n=a(n),w;if(a==="stop")return n}}function Es(n){var w=n.split("/");return w.length>1?w[0]/w[1]:w[0]}function sn(n,w){return n.filter(a=>w.includes(a))}function nn(n,w,a){let I;var D,U,W,B,R="none",F="none",ie="none",q="none",M="none",ne="none",ae="none",N="none",D,U,W,B,X,A,J,V,Y,c,G;G=i=>{var d=[[Math.floor(Math.random()*6)+1,Math.floor(Math.random()*6)+1,Math.floor(Math.random()*12)+1,Math.floor(Math.random()*20)+1],[],["+"],[],[i],[],[0],[]];return a(0,c=T(d)),a(0,c=T(c(y))),fe(c),c(O),c};var K="";function fe(i){console.log("In updateRoll. m(s) is",i(y)),a(2,D=i(y)[0][0]),a(3,U=i(y)[0][1]),a(4,W=i(y)[0][2]),a(5,B=i(y)[0][3]),a(14,X=i(y)[1][0]),a(15,A=i(y)[1][1]),a(16,J=i(y)[1][2]),a(17,V=i(y)[1][3]),i(y)[2],i(y)[3],Y=i(y)[4],a(6,R=a(7,F=a(8,ie=a(9,q="inline")))),a(10,M=a(11,ne=a(12,ae=a(13,N="none"))))}function Ne(){a(6,R=a(7,F=a(8,ie=a(9,q=a(10,M=a(11,ne=a(12,ae=a(13,N="none")))))))),D!=null&&a(6,R="inline"),U!=null&&a(7,F="inline"),W!=null&&a(8,ie="inline"),B!=null&&a(9,q="inline"),X!=null&&a(10,M="inline"),A!=null&&a(11,ne="inline"),J!=null&&a(12,ae="inline"),V!=null&&a(13,N="inline")}c=T([[Math.floor(Math.random()*6)+1,Math.floor(Math.random()*6)+1,Math.floor(Math.random()*12)+1,Math.floor(Math.random()*20)+1],[],["+"],[],[0],[],[0],[]]);var ue=function(){a(2,D=c(y)[0][0]),a(3,U=c(y)[0][1]),a(4,W=c(y)[0][2]),a(5,B=c(y)[0][3]),c(y)[2],c(y)[3],Y=c(y)[4],a(14,X=c(y)[1][0]),a(15,A=c(y)[1][1]),a(16,J=c(y)[1][2]),a(17,V=c(y)[1][3])},j="",S=T([1,2,3,4]),pe=structuredClone,z;z=i=>{if(i[5].length<1){a(0,c=T(i)),console.log("You're already all the way back");return}else{var d=i[7],i=i[5][i[5].length-1];i[7]=d,a(0,c=T(i)),ue(),Ne()}};var Se;Se=i=>{var d=i[6][0];if(i[5].length===i[7].length){console.log("Already at the top"),a(0,c=T(i));return}else{var x=pe(i[7]),i=i[7][d+1];i[7]=x,a(0,c=T(i)),ue(),Ne()}};function xe(){var i=c(y);return console.log("<><><><><><><><> xx is",i),console.log(i[0]),console.log("xx[5].length is ",i[5].length),console.log("index is",i[6]),a(0,c=T(i)),c}function O(i){i[5].push(pe(i)),i[7].push(pe(i)),i[6][0]+=1;var d;Y=i[4];var x;if(i[1].length===2&&i[2].length===1&&(x=i[1],d=tn(i[1][0],i[1][1],i[2][0]),i[0].push(d),i[3].push(d),i[1]=[],a(0,c=T(i))),i[1].length===3&&i[0].push(i[1].pop()),d==20&&sn(x,i[3]).length>0){if(Y===4)a(19,j="You win! "),i[4][0]=0,G(0);else{var Ce=parseInt(i[4][0],10);Ce+=1,a(1,K="           Your score increased to "+Ce),G(Ce)}setTimeout(()=>a(1,K=a(19,j="")),3e3)}return ue(),Ne(),c(y)}var nt=i=>{i[1].push(i[0][0]),i[0].shift(),a(0,c=T(i)),c(O)},Ae=i=>{i[1].push(i[0].splice(1,1)[0]),a(0,c=T(i)),a(0,c=c(O))},Q=i=>{i[1].push(i[0].splice(2,1)[0]),a(0,c=T(i)),a(0,c=c(O))},at=i=>{i[1].push(i[0].splice(3,1)[0]),a(0,c=T(i)),a(0,c=c(O))};function Oe(i){i[2]="+",a(0,c=T(i))}function g(i){i[2]="*",a(0,c=T(i))}function ft(i){i[2]="/",a(0,c=T(i))}function He(i){i[2]="@",a(0,c=T(i))}var E=T(3.1415926535),Xt=i=>i**3,ut=i=>i*i,me=i=>d=>d**i,Jt=i=>d=>1*d+1*i,pt=i=>d=>d*i,be=i=>d=>i;function Vt(){a(23,E=E(ut))}function mt(){a(23,E=E(Xt))}var he=function(d){var x=Es(d.target.value);d.keyCode==13&&a(23,E=E(me(x)))},Gt=function(d){d.keyCode==13&&a(23,E=E(Jt(d.target.value)))},bt=function(d){d.keyCode==13&&a(23,E=E(pt(Es(d.target.value))))},ce=function(d){d.keyCode==13&&a(23,E=E(be(Es(d.target.value))))},Kt=`function fu (a) {                                    // fu
  a[5].push(clone(a));
  a[7].push(clone(a)); // All game states for use in "Back" and "Forward."
  a[6][0] += 1;
    // a[1].push(a[0].pop());
  var result;
  SCORE = a[4];
  var a1;
  if (a[1].length === 2 && a[2].length === 1)   {
    a1 = a[1];
    result = calc(a[1][0], a[1][1],a[2][0]);
    a[0].push(result);
    a[3].push(result);  
    a[1] = [];
    m2 = M(a);
  }

  if (a[1].length === 3) {
    a[0].push(a[1].pop());
  }
 
  if (result == 20 && intersection(a1, a[3]).length > 0) {
      if (SCORE === 4) {
          ZWIN = "You win! "
          a[4][0] = 0;
          runRoll(0);
      }
      else {
          var aint = parseInt(a[4][0], 10);
          aint += 1;
          Z = "           Your score increased to " + aint;
          runRoll(aint); 
      }
      setTimeout(() => Z = ZWIN = "", 3000);
  }
  update();
  sfunc();
  return m2(s); 
}; 

var update = () => { // The button displays will correspond to the values in m2.
  AA = m2(s)[0][0];
  BB = m2(s)[0][1];
  CC = m2(s)[0][2];
  DD = m2(s)[0][3];
  EE = m2(s)[2];
  FF = m2(s)[3];
  SCORE = m2(s)[4];
  WW = m2(s)[1][0];
  XX = m2(s)[1][1];
  YY = m2(s)[1][2];
  ZZ = m2(s)[1][3];
}

function sfunc () {
    b0 = b1 = b2 = b3 = b4 = b5 = b6 = b7 = "none"; // All button displays controlled by b's disappear. 
    if (AA != (undefined && 0)) b0 = "inline"; // Next, selected buttons are diplayed.
    if (BB != (undefined && 0)) b1 = "inline";
    if (CC != (undefined && 0)) b2 = "inline";
    if (DD != (undefined && 0)) b3 = "inline";
    if (WW != (undefined && 0)) b4 = "inline";
    if (XX != (undefined && 0)) b5 = "inline";
    if (YY != (undefined && 0)) b6 = "inline";
    if (ZZ != (undefined && 0)) b7 = "inline";
}`,ht=`function M (x) {
  return function go (func) {
      if (typeof func === "function") {
          x = func(x);
          return go;
      }
      else if (func === "stop") return x;
  }
};`,ye=`var mon3 = M([1,2,3,4]);
function g(ar) {
    var x = (ar.pop())**3;
    ar.unshift(x);
  return ar;
};
function g2 (ar) {return (ar.flatMap(v => (v+1)**3))};
function g3 (ar) {return (ar.flatMap(v => Math.round(v**(1/3))))};`,Qt=`runRoll = x => {
    m2 = M([ [Math.floor(Math.random()*6) + 1, Math.floor(Math.random()*6) + 1, Math.floor(Math.random()*12) + 1, Math.floor(Math.random()*20) + 1], [], [], [], [x] ]);
    updateRoll();
    EEE = "yet to be selected";
    XO = m2('stop');
    AR = [];
    index = 0;
}

const updateRoll = () => {
  AA = m2(s)[0][0];
  BB = m2(s)[0][1];
  CC = m2(s)[0][2];
  DD = m2(s)[0][3];
  
  WW = m2(s)[1][0];
  XX = m2(s)[1][1];
  YY = m2(s)[1][2];
  ZZ = m2(s)[1][3];
  EE = m2(s)[2];
  FF = m2(s)[3];
  SCORE = m2(s)[4];
  b0 = b1 = b2 = b3 = "inline";
  b4 = b5 = b6 = b7 = 'none';
};`,ct=`var click0 = a => {
    a[1].push(a[0][0])
    a[0].shift();
    m2 = M(a);
    m2(fu);
    // sfunc();
};

var click1 = a => {
    a[1].push(a[0].splice(1,1)[0]);
    m2 = M(a);
    m2 = m2(fu);
};

var click2 = a => {
    a[1].push(a[0].splice(2,1)[0]);
    m2 = M(a);
    m2 = m2(fu);
};

var click3 = a => {
    a[1].push(a[0].splice(3,1)[0]);
    m2 = M(a);
    m2 = m2(fu);
};

function clic0 (m) {
  EEE = "add";
  m[2] = "+";
  m2 = M(m) ;
} 

$: clic1 = m => {
  EEE = "subtract";
  m[2] = "-";
  m2 = M(m) ;
} 

function clic2 (m) {
  EEE = "multiply";
  m[2] = "*";
  m2 = M(m) ;
} 

function clic3 (m) {
  EEE = "divide";
  m[2] = "/";
  m2 = M(m) ;
} 

function clic4 (m) {
  EEE = "concat";
  m[2] = "@"
  m2 = M(m);
};`,L=`if (a[1].length === 3) {   
    a[0].push(a[1].pop());  // Returns a clicked third number.
  };`,gt=`function squareFu () {m4 = m4(square)};
function cubeFu () {m4 = m4(cube)};

function divFraction (x) {
    var y = x.split('/');
    if(y.length > 1){
        return (y[0] / y[1])
    }
    else{
        return y[0];
    }
}

var powFu = function powFu (e) {
    var p = divFraction(e.target.value);
    if (e.keyCode == 13) {
        m4 = m4(pow(p));
    }
};
    
var addFu = function addFu (e) {
    if (e.keyCode == 13) {
        m4 = m4(add(e.target.value));
    };
  };
    
var multFu = function multFu (e) {
    if (e.keyCode == 13) {
        m4 = m4(mult(divFraction(e.target.value)))};
};
    
var resetFu = function resetFu (e) {
    if (e.keyCode == 13) {
        m4 = m4(reset2(divFraction(e.target.value)))
    };
};`,yt=`var mon = M(2);  
mon(v=>v**4)(v=>v+5)(v=>v*2);`,ve=`mon('stop');  // 42
mon(v => v*v);`,$t="mon('stop');  // 1764",vt="mon(v => 4)(s); // 4.",de=`mon = M([ 1,[2],[[3]],[[{a:1, b:{c:2}}]] ])
var mon2 = M(mon(s));
log(mon(s) === mon2(s)); // true
mon(v => [ [], [] ]);
log(mon(s) === mon2(s)); // false

log("mon(s) is", mon(s)); // mon(s) is [ [], [] ]
log("mon2(s) is", mon2(s)); // mon2(s) is 
[ 1, (1) [\u2026], (1) [\u2026], (1) [\u2026] ]
0: 1
1: Array [ 2 ]
2: Array [ (1) [\u2026] ]
0: Array [ 3 ]
length: 1
<prototype>: Array []
3: Array [ (1) [\u2026] ]
0: Array [ {\u2026} ]
0: Object { a: 1, b: {\u2026} }
a: 1
b: Object { c: 2 }`,eo="M(2)(v=>v+1)(v=>v*2)(v=>v*7)(s) // 42";const dt=()=>a(20,S=S(on)),we=()=>a(20,S=S(ln)),to=()=>a(20,S=S(rn)),wt=()=>a(20,S=S(i=>[1,2,3,4])),ke=()=>c(nt),oo=()=>c(Ae),kt=()=>c(Q),H=()=>c(at),lo=()=>c(Oe),_e=()=>c(I),ro=()=>c(g),so=()=>c(ft),Ee=()=>c(He),io=()=>c(G(c(y)[4])),no=()=>xe(),_t=()=>c(z),Te=()=>c(Se);return n.$$.update=()=>{n.$$.dirty[0]&2&&a(1,K),n.$$.dirty[0]&2,n.$$.dirty[0]&1&&a(2,D=c(y)[0][0]),n.$$.dirty[0]&1&&a(3,U=c(y)[0][1]),n.$$.dirty[0]&1&&a(4,W=c(y)[0][2]),n.$$.dirty[0]&1&&a(5,B=c(y)[0][3]),n.$$.dirty[0]&1&&c(y)[2],n.$$.dirty[0]&1&&c(y)[3],n.$$.dirty[0]&1&&(Y=c(y)[4]),n.$$.dirty[0]&1&&a(14,X=c(y)[1][0]),n.$$.dirty[0]&1&&a(15,A=c(y)[1][1]),n.$$.dirty[0]&1&&a(16,J=c(y)[1][2]),n.$$.dirty[0]&1&&a(17,V=c(y)[1][3]),n.$$.dirty[0]&1&&c(y)},Y=[0],a(24,I=i=>{i[2]="-",a(0,c=T(i))}),[c,K,D,U,W,B,R,F,ie,q,M,ne,ae,N,X,A,J,V,G,j,S,z,Se,E,I,xe,nt,Ae,Q,at,Oe,g,ft,He,Vt,mt,he,Gt,bt,ce,Kt,ht,ye,Qt,ct,L,gt,yt,ve,$t,vt,de,eo,dt,we,to,wt,ke,oo,kt,H,lo,_e,ro,so,Ee,io,no,_t,Te]}class fn extends Vi{constructor(w){super();Gi(this,w,nn,en,Ki,{},null,[-1,-1,-1,-1])}}export{fn as default};
